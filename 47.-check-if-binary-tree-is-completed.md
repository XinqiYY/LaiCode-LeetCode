# 47. Check If Binary Tree Is Completed

## 题目

![](<.gitbook/assets/image (53).png>)

#### 链接：[https://app.laicode.io/app/problem/47?plan=3](https://app.laicode.io/app/problem/47?plan=3)

## 解法一

Clarification: 判断此树是不是complete

Algorithm:&#x20;

1. 使用queue来BFS遍历，用flag来标记第一次遇到的null，不管left还是right是null，标记flag 为true，并且如果还有下一步循环，但因为flag已经是true，return false

#### <mark style="color:red;">注意：complete tree必须是二叉并且尽可能地靠左。如果遍历时发现左孩子是空的，意味两件事</mark>

1. <mark style="color:red;">最左边已经是空，不满足complete tree</mark>
2. <mark style="color:red;">走到底了</mark>

<mark style="color:red;">不管哪一种情况，都应该吧flag设置为true，意思是已看到底。那么往右孩子看时，必然要退出循环</mark>

<mark style="color:red;">之所以第二次遇到flag时才return，是因为如果走到底了，我们还需要查看cur的右孩子，如果两边同时走到底，return true；</mark>

## 代码

```java
public class Solution {
  public boolean isCompleted(TreeNode root) {
    // Write your solution here
    if (root == null) return true;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    boolean flag = false;
    while (!queue.isEmpty()) {
      TreeNode cur = queue.poll();
      if (cur.left == null) {
        flag = true;
      } else if (flag) {
        return false;
      } else {
        queue.offer(cur.left);
      }

      if (cur.right == null) {
        flag = true;
      } else if (flag) {
        return false;
      } else {
        queue.offer(cur.right);
      }
    }

    return true;
  }
}

```

#### TC & SC:&#x20;

1. TC: O(n)
2. SC: O(n)
